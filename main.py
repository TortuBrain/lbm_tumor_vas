# -*- coding: utf-8 -*-
"""Colab_Lattice_Boltzmann_Modified_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/155kujt_H77nAv-QCIdbQXuR5Z7so760y
"""

import requests


url = 'https://raw.githubusercontent.com/Sinnefa/Simulation-and-Modeling-of-Natural-Processes-Coursera-May-2020/master/Code/lbmFlowAroundCylinder.py'
r = requests.get(url, allow_redirects=True)

open('lattice.py', 'wb').write(r.content)

"""# Numpy LBM"""

import numpy as np
import matplotlib.pyplot as plt
from time import time as ti
from matplotlib import cm
from tqdm import tqdm

##Normal

"""# Extract Macroscopic parameters

This function returns the macroscopic variables density (rho=p; rank-2 tensor --> scalar at every discrete lattice point) and velocity (u; rank-3 tensor x and y velocity at every discrete lattice point)
"""

def macroscopic (fin,nx,ny,v):
    rho = np.sum(fin, axis =0)
    u = np.zeros ((2,nx,ny))
    for i in range(9):
        u[0,:,:] += v[i,0]*fin[i,:,:]
        u[1,:,:] += v[i,1]*fin[i,:,:]
    u /= rho
    return rho,u

"""# Equilibrium

This function returns the equilibrium distribution
"""

def equilibrium(rho, u,v,t,nx,ny):              
    usqr = 3/2 * (u[0]**2 + u[1]**2)
    feq = np.zeros((9,nx,ny))
    for i in range(9):
        cu = 3 * (v[i,0]*u[0,:,:] + v[i,1]*u[1,:,:])
        feq[i,:,:] = rho*t[i] * (1 + cu + 0.5*cu**2 - usqr)
    return feq

"""# Flow Obstacle

The numpy function fromfunction uses this function to broadcast the coordinates of the "obstacle".
This currying is just to make a function that doesn't need any global variables. You can think about how you would use something like porespy or a CT scan to generate a porous medium that you could substitute for this function
"""

def obstacle_fun(cx, cy, r):
    def inner (x,y):
        return (x-cx)**2+(y-cy)**2<r**2
    return inner

"""# Inlet Velocity

This function instantiates the inlet boundary velocity (with a small perturbation)
"""

def inivel(uLB, ly):
    def inner (d, x, y):
        return (1-d) * uLB * (1 + 1e-4*np.sin(y/ly*2*np.pi))
    return inner

"""# Model Parameters
Images
"""

Re = 10.0 #Reynolds Number
#---------------------------------------------
maxIter = 1000
nx,ny = 4200,1800          #Domain Dimensions
nx,ny = 420,180            #Domain Dimensions
ly = ny-1
uLB = 0.04                  #Inlet velocity NON PHYSICAL?
cx,cy,r = nx//4,ny//2,ny/9  # Cylinder coordinates and radius (as integers)
nulb = uLB*r/Re             #Viscosity
omega = 1/(3*nulb+0.5)      #Relaxation parameter

#lattice velocities

v = np.array([
    [1,1],
    [1,0],
    [1,-1],
    [0,1],
    [0,0],
    [0,-1],
    [-1,1],
    [-1,0],
    [-1,-1]
])
#weights
t = np.array([
    1/36,
    1/9,
    1/36,
    1/9,
    4/9,
    1/9,
    1/36,
    1/9,
    1/36
])

col_0 = np.array([0,1,2])
col_1 = np.array([3,4,5])
col_2 = np.array([6,7,8])

#instantiate the cylindrical obstacle
obstacle = np.fromfunction(obstacle_fun(cx,cy,r),(nx,ny))
if True:
    plt.imshow(obstacle)
    
#initial velocity profile
vel = np.fromfunction(inivel(uLB,ly),(2,nx,ny))

#initiate fin to equilibrium (rho=1)
fin = equilibrium(1,vel,v,t,nx,ny)

"""# Time Stepping Loop"""

########################################################
# Time-Stepping
########################################################
t0 = ti()
for time in tqdm(range(maxIter)):
    #outflow boundary condition (right side) NEUMANN BC! No gradient
    fin[col_2,-1,:] = fin[col_2,-2,:]
    
    #compute macroscopic variables
    rho, u = macroscopic(fin,nx,ny,v)
    
    #inlet boundary condition (left wall)
    u[:,0,:] = vel[:,0,:]
    rho[0,:] = 1/(1-u[0,0,:]) * ( np.sum(fin[col_1,0,:], axis=0) +
                                  2*np.sum(fin[col_2,0,:], axis=0))
    feq = equilibrium(rho,u,v,t,nx,ny)
    fin[col_0,0,:] = feq[col_0,0,:] + fin[col_2,0,:]-feq[col_2,0,:]
    
    #Collide
    fout = fin - omega*(fin-feq)
    
    #bounceback
    for i in range(9):
        fout[i,obstacle] = fin[8-i,obstacle]
    
    #stream
    for i in range(9):
        # Be careful with this -> numpy.roll cycles through an array by an axis
        # and the last element becomes the first. This implements a periodic
        # boundary in a very compact syntax, but needs to be reworked for other
        # implementations
        fin[i,:,:] = np.roll(np.roll(fout[i,:,:],v[i,0],axis =0
                                    ),
                            v[i,1], axis=1
                            )
    
    #Output an image every 100 iterations
    if (time%100 == 0):
        plt.clf()
        plt.imshow(np.sqrt(u[0]**2+u[1]**2).T,cmap=cm.Reds)
        plt.savefig("vel{0:03d}.png".format(time//100))

tf = ti()-t0
print("time to exceute = ",tf)

"""# Working with Torch"""

import numpy as np
import matplotlib.pyplot as plt
from time import time as ti
from matplotlib import cm
from tqdm import tqdm
from numpy import fromfunction
from numpy import pi

##Normal

from torch import zeros,tensor,roll,sin,sqrt,linspace
from torch import sum as tsum
import torch

"""# Device Selection

You can select the device if you know it is an available resource, or you can use this little conditional to select "cuda" (GPU) if its available and it will default  to "cpu" if it is not.
"""

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
##########
#Uncomment the next line to hard code the use of cpu
#device = torch.device('cpu')
##########
print("Using device", device)

"""# Extract macroscopic parameters

This function returns the macroscopic variables density (rho=p) and velocity (u). This is used to extract the macroscopic velocity from densities at a lattice point. Refer to equation 15 page 34 from Lattice Boltzmann Modelling. An Introduction for Geoscientist and Engineers.
v is our variable for the lattice velocities which is the same as e where the subscript a refers to the [0,8] lattice direction and fin is the directional density (f in equation 15)
"""

def macroscopic (fin,nx,ny,v):
    rho = tsum(fin, axis =0).to(device)
    u = zeros ((2,nx,ny)).to(device)
    for i in range(9):
        u[0,:,:] += v[i,0]*fin[i,:,:]
        u[1,:,:] += v[i,1]*fin[i,:,:]
    u /= rho
    return rho,u

"""# Equilibrium"""

def equilibrium(rho, u,v,t,nx,ny):              
    usqr = 3/2 * (u[0]**2 + u[1]**2)
    feq = zeros((9,nx,ny))
    for i in range(9):
        cu = 3 * (v[i,0]*u[0,:,:] + v[i,1]*u[1,:,:])
        feq[i,:,:] = rho*t[i] * (1 + cu + 0.5*cu**2 - usqr)
    return feq.to(device)

"""# Flow obstacle"""

def obstacle_fun(cx, cy, r):
    def ret_fun (x,y):
        return (x-cx)**2+(y-cy)**2<r**2
    return ret_fun

def obstacle_porous(**kwargs):
    return ~kwargs['generator'](**kwargs)

"""# Inlet velocity"""

def inivel(uLB, ly, d, nx,ny):
    _,yy=torch.meshgrid(linspace(0,nx-1,nx),linspace(0,ny-1,ny))
    yy.to(device)
    vel = zeros((d,nx,ny)).to(device)
    for dir in range(d):
        vel[dir,:,:] = (1-d) * uLB * (1 + 1e-4*sin(yy/ly*2*np.pi))
    return vel

"""# Importing Porespy"""

import porespy as ps
from skimage.measure import regionprops,label
import numpy as np

"""# Model Parameter"""

kwargs = {"shape":[100,100],"porosity":.5,"blobiness":0.5}

from matplotlib import pylab
matrix = pylab.imread('data.png')
retinal=matrix[::,::,0]
retinal=np.array(retinal, dtype=bool)

Re = 10.0 #Reynolds Number
#---------------------------------------------
maxIter = 8000
nx,ny = 750, 647            #Domain Dimensions
ly = ny-1
uLB = 0.04                  #Inlet velocity NON PHYSICAL?
cx,cy,r = nx//4,ny//2,ny/9  # Cylinder coordinates and radius (as integers)
nulb = uLB*r/Re             #Viscosity
omega = 1/(3*nulb+0.5)      #Relaxation parameter

#lattice velocities

v = tensor([
    [1,1],
    [1,0],
    [1,-1],
    [0,1],
    [0,0],
    [0,-1],
    [-1,1],
    [-1,0],
    [-1,-1]
]).int().to(device)


#weights
t = tensor([
    1/36,
    1/9,
    1/36,
    1/9,
    4/9,
    1/9,
    1/36,
    1/9,
    1/36
]).float().to(device)

col_0 = tensor([0,1,2]).long().to(device)
col_1 = tensor([3,4,5]).long().to(device)
col_2 = tensor([6,7,8]).long().to(device)

#instantiate the obstacle
kwargs['shape'] = [nx,ny]
obstacle = tensor(~retinal).to(device)
#obstacle = torch.tensor(fromfunction(obstacle_fun(cx,cy,r),(nx,ny)))
plt.imshow(obstacle.cpu())

#initial velocity profile
vel = inivel(uLB,ly,2,nx,ny)

#initiate fin to equilibrium (rho=1)
fin = equilibrium(1,vel,v,t,nx,ny).to(device)

"""# Timming


"""

########################################################
# Time-Stepping
########################################################
t0 = ti()
for time in tqdm(range(maxIter)):
    #outflow boundary condition (right side) NEUMANN BC! No gradient
    fin[col_2,-1,:] = fin[col_2,-2,:]
    
    #compute macroscopic variables
    rho, u = macroscopic(fin,nx,ny,v)
    
    #inlet boundary condition (left wall)
    u[:,0,:] = vel[:,0,:]
    rho[0,:] = 1/(1-u[0,0,:]) * ( tsum(fin[col_1,0,:], axis=0) +
                                  2*tsum(fin[col_2,0,:], axis=0))
    feq = equilibrium(rho,u,v,t,nx,ny)
    fin[col_0,0,:] = feq[col_0,0,:] + fin[col_2,0,:]-feq[col_2,0,:]
    
    #Collide
    fout = fin - omega*(fin-feq)
    
    #bounceback
    for i in range(9):
        fout[i,obstacle] = fin[8-i,obstacle]
    
    #stream
    for i in range(9):
        # Be careful with this -> numpy.roll cycles through an array by an axis
        # and the last element becomes the first. This implements a periodic
        # boundary in a very compact syntax, but needs to be reworked for other
        # implementations
        fin[i,:,:] = roll(roll(fout[i,:,:],v[i,0].item(),dims =0
                                    ),
                            v[i,1].item(), dims=1
                            )
    
    #Output an image every 100 iterations
    if (time%100 == 0):
        plt.clf()
        u_cpu = u.cpu()
        x_temp = int(round(5*nx/ny))
        y_temp = int(round(5))
        
        plt.imshow(sqrt(u_cpu[0]**2+u_cpu[1]**2).T,cmap='jet')
        
        #plt.savefig("vel{0:03d}.png".format(time//100))

tf = ti()-t0
print("time to exceute = ",tf)



